# 浏览器接收到html文件
1.  词法分析 => 标记 => node节点 => DOM树

# 浏览器接收到css文件
步骤同上 => CSSOM树
递归CSSOM树确定具体的元素到底是什么样式

# 渲染树
DOM树 + CSSOM树 = render树
渲染树只包含需要显示的节点

# 回流
根据render树绘制页面布局

# 为什么操作DOM性能很差？
1. 本身存在JS执行引擎和渲染引擎，会造成多线程通信并发
2. 可能引起重绘和回流

# 什么时候会阻塞渲染
html, css 
<script src=""></script>

# 重绘和回流
回流：节点的几何信息发生变化
重绘：节点更改不影响布局的信息
回流一定会重绘，重绘不一定会回流

会导致性能问题的操作
1. 改变window大小
2. 改变字体大小
3. display:none

# 减少重绘和回流
1. 用visibility  代替 display: none
2. 不要把节点属性值放在一个循环里面当成循环的变量
3. 尽量不要用table变量

1. HTML parser：根据 HTML 构建 DOM 树。
2. CSS parser：根据 CSS 构建 CSSOM 树。
3. 如果遇到 script 标签的话，会判断是否存在 defer 或者 async ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。
4. Attachment：CSSOM 树和 DOM 树构建完成后会开始生成 Render 树。
5. Layout: 布局。确定页面元素的布局、样式等等诸多方面的东西。
6. GPU painting: 像素绘制页面，将内容显示在屏幕上了。


7. reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。

8. repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。

注意：(1)display:none 的节点不会被加入Render Tree，而visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。
　　   (2)display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。
　　　(3)有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。
Reflow 的成本比 Repaint 的成本高得多的多。一个节点的 Reflow 很有可能导致子节点，甚至父节点以及兄弟节点的 Reflow 。在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的。

# 如何减少和避免重排

1. 直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）；

2. 让要操作的元素进行”离线处理”，处理完后一起更新；

a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；
b) 使用display:none技术，只引发两次回流和重绘；
c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；

3.不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存；

4. 让元素脱离动画流，减少回流的Render Tree的规模；
